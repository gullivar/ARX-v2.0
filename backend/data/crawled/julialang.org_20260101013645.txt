The Julia Programming Language Download Docs Learn Blog Community Contribute JSoC Star Sponsor The Julia Programming Language Install v1.12.3 Docs Community Star Julia in a Nutshell Fast Julia was designed for high performance .
        Julia programs automatically compile to efficient native code via LLVM, and support multiple platforms . Dynamic Julia is dynamically typed , feels like a scripting language, and has good support for interactive use, but can also optionally be separately compiled. Reproducible Reproducible environments make it possible to recreate the same Julia environment every time, across platforms, with pre-built binaries . Composable Julia uses multiple dispatch as a paradigm, making it easy to express many object-oriented and functional programming patterns. The talk on the Unreasonable Effectiveness of Multiple Dispatch explains why it works so well. General Julia provides asynchronous I/O , metaprogramming , debugging , logging , profiling , a package manager , and the ability to build binaries . Open source Julia is an open source project with over 1,000 contributors. It is made available under the MIT license . The source code is available on GitHub. Julia has a welcoming community accessible to all backgrounds. â€¹ Multiple Dispatch julia> greet(x) = "Hello, $(x)!" julia> greet(x:: Number ) = "Hello, #$(x)!" julia> greet( "world" ), greet( 42 )
( "Hello, world!" , "Hello, #42!" ) Display Customization julia> struct Nutshell{T}
           contents::T end julia> Base.show(io::IO, n::Nutshell) = print(io, "ðŸ¥œ " , n.contents, " ðŸ¥œ" ) julia> Nutshell( "Julia" )
ðŸ¥œ Julia ðŸ¥œ Unicode & Math julia> Î±, Î² = 0.5 , 0.3 julia> f(x) = Î±*x + Î² julia> âˆ‘(v) = reduce(+, v) julia> âˆ‘(f.(1:5)) 9.0 Comprehensions julia> [x^ 2 for x in 1 : 5 ] 5 -element Vector{ Int64 }: 1 4 9 16 25 julia> Dict(c => i for (i,c) in enumerate( "julia" ))
Dict{ Char , Int64 } with 5 entries: 'u' => 2 'a' => 5 'i' => 4 'j' => 1 'l' => 3 Broadcasting julia> A = [ 1 2 ; 3 4 ] 2 Ã— 2 Matrix{ Int64 }: 1 2 3 4 julia> sin.(A) .+ 1 2 Ã— 2 Matrix{ Float64 }: 1.84147 1.9093 1.14112 0.243198 Piping & Composition julia> 1 : 5 |> sum |> sqrt 3.872983346207417 julia> (sqrt âˆ˜ sum)( 1 : 5 ) 3.872983346207417 julia> map(exp âˆ˜ abs, [ -1 , 2 , -3 ])
[ 2.718 , 7.389 , 20.086 ] Destructuring julia> (a, b, c) = 1 : 3 julia> a, c
( 1 , 3 ) julia> head, tail... = [ "first" , "second" , "third" ] julia> head, tail
( "first" , [ "second" , "third" ]) Metaprogramming julia> ex = :( 1 + 2 * 3 )
:(1 + 2 * 3) julia> typeof (ex)
Expr julia> eval(ex) 7 Easy Package Install julia> using DataFrames
 â”‚ Package DataFrames not found, but a package named DataFrames is available from a registry.
 â”‚ Install package?
 â”‚ (myproject) pkg> add DataFrames
 â”” (y/n/o) [y]: y julia> df = DataFrame(name=[ "Alice" , "Bob" ], age=[ 25 , 30 ]) 2 Ã— 2 DataFrame
 Row â”‚ name    age
     â”‚ String  Int64
â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1 â”‚ Alice      25
   2 â”‚ Bob        30 Defaults & Keyword Args julia> function greet(name, greeting= "Hello" ; punctuation= "!" ) "$greeting, $name$punctuation" end julia> greet( "Julia" ) "Hello, Julia!" julia> greet( "world" , "Hi" ; punctuation= "." ) "Hi, world." Multi-threading julia> function fib(n)
           n < 2 && return n
           t = Threads.@spawn fib(n - 2 ) return fib(n - 1 ) + fetch(t) end julia> fib( 10 ) 55 julia> Threads.nthreads() 8 Built-in REPL Modes julia> # Press ] for package mode (@v1.12) pkg> status
Status `~/.julia/environments/v1.12/Project.toml`
  [6e4b80f9] BenchmarkTools v1.5.0 julia> # Press ; for shell mode shell> ls *.jl
main.jl  test.jl  utils.jl julia> # Press ? for help mode help?> sum
  sum(f, itr) â€“ Sum the results of calling f on each element of itr. Code Introspection (simplified) julia> f(x, y) = x + y julia> @code_warntype f( 1 , 2 )
MethodInstance for f(:: Int64 , :: Int64 )
Arguments
  x:: Int64 y:: Int64 Body:: Int64 â”‚   %1 = (x + y):: Int64 â””â”€â”€ return %1 julia> @code_llvm f( 1 , 2 )
define i64 @julia_f(...) {
   %0 = add i64 %"y::Int64", %"x::Int64"
   ret i64 %0
} julia> @code_native f( 1 , 2 )
   add   x0, x1, x0
   ret â€º Ecosystem Visualization General Purpose Data Science Machine Learning Scientific Domains Parallel Computing General Computing Build, Deploy or Embed Your Code Julia makes it possible to build complete applications. Write web UIs with Dash.jl and Genie.jl or native UIs with Gtk4.jl . Pull data from a variety of databases . Build shared libraries and executables with PackageCompiler . Deploy on a webserver with HTTP.jl or embedded devices. Powerful shell integration make it easy to managing other processes . Julia has foreign function interfaces for C, Fortran , C++ , Python , R , Java , Mathematica , Matlab ,
                and many other languages. Julia can also be embedded in other programs through its embedding API . Julia's PackageCompiler makes it possible to build binaries from Julia programs that can be integrated into larger projects. Python programs can call Julia using juliacall . R programs can do the same with R's JuliaCall , which is demonstrated by calling MixedModels.jl from R . Mathematica supports calling Julia through its External Evaluation System . Parallel Computing Parallel and Heterogeneous Computing Julia is designed for parallelism, and provides built-in primitives for parallel computing at every level: instruction level parallelism , multi-threading , GPU computing , and distributed computing .
                The Celeste.jl project achieved 1.5 PetaFLOP/s on the Cori supercomputer at NERSC using 650,000 cores. The Julia compiler can also generate native code for GPUs . Packages such as DistributedArrays.jl and Dagger.jl provide higher levels of abstraction for parallelism.
		Distributed Linear Algebra is provided by packages like Elemental.jl and TSVD.jl . MPI style parallelism is also available through MPI.jl . Machine Learning Scalable Machine Learning The MLJ.jl package provides a unified interface to common machine learning algorithms, which include generalized linear models , decision trees , and clustering . Flux.jl and Lux.jl are powerful packages for Deep Learning.
		  Packages such as Metalhead.jl , ObjectDetector.jl , and TextAnalysis.jl provide ready to use pre-trained models for common tasks. AlphaZero.jl provides a high performance implementation of the reinforcement learning algorithms from AlphaZero. Turing.jl is a best in class package for probabilistic programming. Scientific Computing Rich Ecosystem for Scientific Computing Julia is designed from the ground up to be very good at numerical and scientific computing.
                This can be seen in the abundance of scientific tooling written in Julia, such as the state-of-the-art differential equations ecosystem (DifferentialEquations.jl) , optimization tools ( JuMP.jl and Optimization.jl ), iterative linear solvers ( Krylov.jl , LinearSolve.jl ), Fast Fourier transforms (AbstractFFTs.jl) , and much more. General purpose simulation frameworks are available for Scientific Machine Learning , Quantum computing and much more. Julia also offers a number of domain-specific ecosystems, such as in biology (BioJulia) , operations research (JuMP Dev) , image processing (JuliaImages) , quantum physics (QuantumBFS) , nonlinear dynamics (JuliaDynamics) , quantitative economics (QuantEcon) , astronomy (JuliaAstro) and ecology (EcoJulia) . With a set of highly enthusiastic developers and maintainers, the scientific ecosystem in Julia continues to grow rapidly. Data Science Interact with your Data The Julia data ecosystem provides DataFrames.jl to work with datasets, and perform common data manipulations. CSV.jl is a fast multi-threaded package to read CSV files and integration with the Arrow ecosystem is in the works with Arrow.jl . Online computations on streaming data can be performed with OnlineStats.jl .
                The Queryverse provides query, file IO and visualization functionality. In addition to working with tabular data, the JuliaGraphs packages make it easy to work with combinatorial data. Julia can work with almost all databases using JDBC.jl and ODBC.jl drivers. In addition, it also integrates with the Spark ecosystem through Spark.jl . Visualization Data Visualization and Plotting Data visualization has a complicated history. Plotting software makes trade-offs between features and simplicity, speed and beauty, and a static and dynamic interface. Some packages make a display and never change it, while others make updates in real-time. Plots.jl is a visualization interface and toolset. It provides a common API across various backends , like GR.jl , PyPlot.jl , and PlotlyJS.jl . Makie.jl is a sophisticated package for complex graphics and animations. Users who are used to "grammar of graphics" plotting APIs should take a look at Gadfly.jl . VegaLite.jl provides the Vega-Lite grammar of interactive graphics interface as a Julia package. For those who do not wish to leave the comfort of the terminal, there is also UnicodePlots.jl . Lorenz Attractor in Julia Ã— function fill_twos!(a)
  for i=1:length(a)
    a[i] = 2
  end
end

function fast_strange_twos(n)
  a = Array(randbool() ? Int64 : Float64, n)
  fill_twos!(a)
  return a
end Close JuliaCon 2025 Julia Channel on YouTube JuliaCon 2025 videos JuliaCon Local Paris 2025 videos Packages Julia has been downloaded over 100 million times and the Julia community has registered over 12,000 Julia packages for community use.
      These include various mathematical libraries, data manipulation tools, and packages for general purpose computing. In addition to these, you can easily use libraries from Python , R , C/Fortran , and C++ , and Java .
      If you do not find what you are looking for, ask on Discourse , or even better, contribute one ! JuliaHub: Package Search JuliaPackages: Trending Feed of new Julia packages Recent Blog Posts This Month in Julia World (November 2025) 1 December 2025 Community Newsletter for November 2025 Launching the Julia Security Working Group 25 November 2025 Launching the Julia Security Working Group This Month in Julia World (October 2025) 1 November 2025 Community Newsletter for October 2025 Visit Blog Talk to us Discourse Discourse GitHub Source code Zulip Zulip Slack Slack Twitter #JuliaLang Videos YouTube LinkedIn LinkedIn Editors and IDEs VS Code VS Code Extension Jupyter Jupyter kernel Pluto.jl Simple reactive notebooks Vim Vim plugin Emacs Emacs plugin Zed Zed Extension Essential Tools Debugger Debugger.jl Profiler Profile (Stdlib) Revise Revise.jl GPUs JuliaGPU About Get Help Governance Publications Sponsors Install Manual Downloads Source Code Current Stable Release Longterm Support Release Documentation JuliaAcademy YouTube Getting Started FAQ Books Community Code of Conduct Stewards Diversity JuliaCon User/Developer Survey Shop Merchandise Contributing Contributor's Guide Issue Tracker Report a Security Issue Help Wanted Issues Good First Issue Dev Docs This site is powered by Franklin.jl , and the Julia Programming Language . Â©2025 JuliaLang.org contributors . The content on this website is made available under the MIT license . Sponsor